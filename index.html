<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agape Massage Scheduler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@500;600;700&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #3a3a32;
            --card-bg: #f5f2ea;
            --accent: #c9a55c;
            --accent-hover: #b8924a;
            --text-dark: #2d2d26;
            --text-muted: #6b6b5e;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            padding: 24px;
            color: var(--text-dark);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--card-bg);
            border-radius: 20px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid rgba(45,45,38,0.08);
            background: rgba(245,242,234,0.6);
        }

        .tab {
            flex: 1;
            padding: 18px;
            text-align: center;
            cursor: pointer;
            font-weight: 500;
            font-size: 15px;
            border: none;
            background: none;
            transition: all 0.2s;
            color: var(--text-muted);
            font-family: inherit;
        }

        .tab:hover {
            background: rgba(201,165,92,0.15);
            color: var(--text-dark);
        }

        .tab.active {
            background: var(--card-bg);
            color: var(--accent);
            border-bottom: 3px solid var(--accent);
            margin-bottom: -2px;
            font-weight: 600;
        }

        .tab-content {
            display: none;
            padding: 40px;
        }

        .tab-content.active {
            display: block;
        }

        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-dark);
        }

        h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 22px;
            font-weight: 600;
            margin: 28px 0 16px;
            color: var(--text-dark);
        }

        .subtitle {
            color: var(--text-muted);
            margin-bottom: 32px;
            font-size: 15px;
        }

        .form-group {
            margin-bottom: 24px;
        }
        .massage-prefs-section .form-group {
            margin-bottom: 16px;
        }
        .massage-prefs-section .form-group:last-child {
            margin-bottom: 0;
        }
        .backup-description {
            color: #6b7280;
            font-size: 14px;
            margin: 0 0 12px 0;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-dark);
        }

        input, select, textarea {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid rgba(45,45,38,0.15);
            border-radius: 12px;
            font-size: 15px;
            font-family: inherit;
            background: rgba(255,255,255,0.8);
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(201,165,92,0.2);
        }

        .date-option {
            background: rgba(255,255,255,0.6);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 12px;
            border: 1px solid rgba(45,45,38,0.08);
        }

        .date-option input[type="date"] {
            margin-bottom: 8px;
        }

        .time-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .add-date-btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
            margin-top: 12px;
        }

        .add-date-btn:hover {
            background: var(--accent-hover);
        }

        .remove-btn {
            background: #c45c4a;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            margin-top: 8px;
        }

        .remove-btn:hover {
            background: #a84a3a;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
            margin-top: 16px;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: rgba(45,45,38,0.08);
            color: var(--text-dark);
            border: 1px solid rgba(45,45,38,0.15);
            padding: 14px 32px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
            margin-top: 16px;
            margin-left: 8px;
        }

        .btn-secondary:hover {
            background: rgba(45,45,38,0.12);
        }

        .availability-group {
            background: rgba(255,255,255,0.6);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
            border: 1px solid rgba(45,45,38,0.08);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .time-range {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
        }

        .massage-preferences {
            display: grid;
            gap: 12px;
        }

        .preference-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .preference-option:last-child {
            margin-bottom: 0;
        }

        .preference-option input[type="radio"],
        .preference-option input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .preference-option label {
            cursor: pointer;
        }

        .schedule-output {
            background: rgba(255,255,255,0.6);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid rgba(45,45,38,0.08);
        }

        .schedule-header {
            background: var(--bg-dark);
            color: var(--card-bg);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .schedule-header h2 { color: var(--card-bg); }

        .schedule-slot {
            background: rgba(255,255,255,0.9);
            padding: 16px;
            border-left: 4px solid var(--accent);
            margin-bottom: 12px;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.06);
        }

        .schedule-slot.break {
            border-left-color: #c9a55c;
            background: rgba(201,165,92,0.15);
        }

        .slot-time {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
        }

        .slot-details {
            color: var(--text-muted);
            font-size: 14px;
        }

        .alert {
            padding: 16px 20px;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .alert-warning {
            background: rgba(201,165,92,0.2);
            border: 1px solid var(--accent);
            color: #5c4a20;
        }

        .alert-success {
            background: rgba(107,160,107,0.2);
            border: 1px solid #6ba06b;
            color: #2d4a2d;
        }

        .alert-info {
            background: rgba(201,165,92,0.15);
            border: 1px solid rgba(201,165,92,0.4);
            color: var(--text-dark);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: rgba(255,255,255,0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(45,45,38,0.08);
        }

        .stat-value {
            font-family: 'Cormorant Garamond', serif;
            font-size: 24px;
            font-weight: 600;
            color: var(--accent);
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 14px;
            margin-top: 4px;
        }

        .response-list {
            margin-top: 24px;
        }

        .response-item {
            background: rgba(255,255,255,0.8);
            padding: 14px;
            border-radius: 10px;
            margin-bottom: 8px;
            border: 1px solid rgba(45,45,38,0.08);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        .response-item-details {
            flex: 1;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .modal-content {
            background: var(--bg-light);
            border-radius: 16px;
            padding: 24px;
            max-width: 480px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            margin: 0 0 20px 0;
        }

        .availability-edit-list {
            margin: 12px 0;
        }

        .availability-edit-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .availability-edit-row select {
            padding: 8px 10px;
        }

        .availability-edit-row .remove-btn {
            padding: 4px 10px;
            margin: 0;
            font-size: 18px;
            line-height: 1;
        }

        .hidden {
            display: none;
        }

        .calendar {
            display: inline-block;
            background: rgba(255,255,255,0.8);
            border-radius: 16px;
            border: 1px solid rgba(45,45,38,0.08);
            padding: 20px;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .calendar-header button {
            background: rgba(201,165,92,0.2);
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 8px 14px;
            border-radius: 10px;
            color: var(--text-dark);
        }

        .calendar-header button:hover {
            background: rgba(201,165,92,0.35);
        }

        .calendar-title {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 600;
            font-size: 18px;
            color: var(--text-dark);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
        }

        .calendar-day-header {
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            padding: 8px 4px;
        }

        .calendar-day {
            aspect-ratio: 1;
            min-height: 38px;
            min-width: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .calendar-day:not(.empty):not(.other-month):hover {
            background: rgba(201,165,92,0.2);
        }

        .calendar-day.empty,
        .calendar-day.other-month {
            color: #b8b8a8;
            cursor: default;
        }

        .calendar-day.selected {
            background: var(--accent);
            color: white;
            font-weight: 600;
        }

        .calendar-day.today {
            border-color: var(--accent);
        }

        .selected-date-tag {
            display: inline-block;
            background: var(--accent);
            color: white;
            padding: 6px 12px;
            border-radius: 10px;
            margin: 4px;
            font-size: 13px;
        }

        .time-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            max-width: 600px;
        }

        .time-slot {
            padding: 12px;
            border: 2px solid rgba(45,45,38,0.12);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            background: rgba(255,255,255,0.8);
            user-select: none;
        }

        .time-slot:hover {
            border-color: var(--accent);
            background: rgba(201,165,92,0.15);
        }

        .time-slot.selected {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .time-slot.in-range {
            background: rgba(201,165,92,0.25);
            border-color: var(--accent);
        }

        .availability-summary-item {
            padding: 10px;
            background: rgba(255,255,255,0.6);
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 14px;
        }

        /* Resident view: hide admin tabs, show only the form */
        .resident-view .tabs {
            display: none;
        }
        .resident-view #admin-tab,
        .resident-view #schedule-tab {
            display: none !important;
        }
        .resident-view #resident-tab {
            display: block !important;
        }

        .btn-danger {
            background: #c45c4a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
        }
        .btn-danger:hover {
            background: #a84a3a;
        }

        #recent-sessions {
            background: rgba(201,165,92,0.12) !important;
            border-color: rgba(201,165,92,0.3) !important;
        }
        #recent-sessions a:hover {
            background: rgba(201,165,92,0.2) !important;
        }
    </style>
    <!-- Supabase - load in head so it's ready when page needs it -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.js"></script>
</head>
<body>
    <div class="container" id="app-container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('admin', event)">1. Organizer Setup</button>
            <button class="tab" onclick="switchTab('resident', event)">2. Resident Availability</button>
            <button class="tab" onclick="switchTab('schedule', event)">3. View Schedule</button>
        </div>

        <!-- ADMIN SETUP TAB -->
        <div id="admin-tab" class="tab-content active">
            <h1>Admin Setup</h1>
            <p class="subtitle">Configure available dates and share the resident form link</p>

            <div id="recent-sessions" class="hidden" style="margin-bottom: 24px; padding: 16px; border-radius: 12px;">
                <h3 style="margin-bottom: 12px; font-size: 16px;">Your recent sessions</h3>
                <p style="color: #6b7280; font-size: 14px; margin-bottom: 12px;">Click to return to a session:</p>
                <div id="recent-sessions-list"></div>
            </div>

            <div class="form-group">
                <label>Session Name (optional)</label>
                <input type="text" id="session-name" placeholder="e.g., February 2026 Massage">
            </div>

            <h2>Available Dates</h2>
            <p style="color: #6b7280; margin-bottom: 16px;">Click dates on the calendar to select them</p>
            <div id="calendar-container"></div>
            <div id="selected-dates-display" style="margin-top: 16px; padding: 12px; background: #f9fafb; border-radius: 6px; display: none;">
                <strong>Selected dates:</strong>
                <div id="selected-dates-list" style="margin-top: 8px;"></div>
            </div>

            <button class="btn-primary" onclick="saveAdminSetup()">Submit Dates</button>
            
            <div id="admin-output" class="hidden" style="margin-top: 24px;">
                <div class="alert alert-success">
                    <strong>Setup saved!</strong> Share this link with residents:
                    <div style="margin-top: 8px; display: flex; gap: 8px; align-items: center;">
                        <div style="flex: 1; padding: 10px; background: rgba(255,255,255,0.9); border-radius: 8px; font-family: monospace; font-size: 14px;" id="form-link"></div>
                        <button class="btn-secondary" style="margin: 0; white-space: nowrap;" onclick="navigator.clipboard.writeText(document.getElementById('form-link').textContent); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy', 2000)">Copy</button>
                    </div>
                </div>
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
                    <button class="btn-danger" onclick="deleteEvent()">Delete this event</button>
                </div>
            </div>
        </div>

        <!-- RESIDENT FORM TAB -->
        <div id="resident-tab" class="tab-content">
            <h1>Agape Massage Availability</h1>
            <p class="subtitle">Let us know when you're available and your massage preferences</p>

            <div class="form-group">
                <label>Your Name</label>
                <input type="text" id="resident-name" required>
            </div>

            <h2>Your Availability</h2>
            <p style="color: #6b7280; margin-bottom: 16px;">Click a date to set your available hours for that day</p>
            <div id="resident-calendar-container"></div>
            
            <div id="time-selector" class="hidden" style="margin-top: 24px;">
                <h3 id="selected-date-title" style="margin-bottom: 16px;"></h3>
                <div id="time-grid" style="margin-bottom: 16px;"></div>
                <div style="display: flex; gap: 12px; margin-top: 16px;">
                    <button class="btn-secondary" onclick="clearTimeSelection()">Clear Times</button>
                    <button class="btn-primary" onclick="document.getElementById('time-selector').classList.add('hidden')">Done</button>
                </div>
            </div>
            
            <div id="resident-availability-summary" class="hidden" style="margin-top: 24px; padding: 16px; background: #f9fafb; border-radius: 8px;">
                <strong>Your availability:</strong>
                <div id="availability-summary-list" style="margin-top: 12px;"></div>
            </div>

            <h2>Massage Preferences</h2>
            <div class="massage-prefs-section">
            <div class="form-group">
                <label>Preferred Length</label>
                <div class="massage-preferences">
                    <div class="preference-option">
                        <input type="radio" name="preferred-length" value="20" id="pref-20">
                        <label for="pref-20">20 min clothed stretches ($30)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="preferred-length" value="50" id="pref-50">
                        <label for="pref-50">50 min massage ($70)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="preferred-length" value="80" id="pref-80" checked>
                        <label for="pref-80">80 min massage ($110)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="preferred-length" value="110" id="pref-110">
                        <label for="pref-110">110 min massage ($150)</label>
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>Backup Preferences (optional)</label>
                <p class="backup-description">Select other lengths you'd be willing to do if your preferred time doesn't fit</p>
                <div class="massage-preferences">
                    <div class="preference-option" data-length="20">
                        <input type="checkbox" name="backup-length" value="20" id="backup-20">
                        <label for="backup-20" style="margin: 0;">20 min clothed stretches ($30)</label>
                    </div>
                    <div class="preference-option" data-length="50">
                        <input type="checkbox" name="backup-length" value="50" id="backup-50">
                        <label for="backup-50" style="margin: 0;">50 min massage ($70)</label>
                    </div>
                    <div class="preference-option" data-length="80">
                        <input type="checkbox" name="backup-length" value="80" id="backup-80">
                        <label for="backup-80" style="margin: 0;">80 min massage ($110)</label>
                    </div>
                    <div class="preference-option" data-length="110">
                        <input type="checkbox" name="backup-length" value="110" id="backup-110">
                        <label for="backup-110" style="margin: 0;">110 min massage ($150)</label>
                    </div>
                </div>
            </div>
            </div>

            <button id="resident-submit-btn" class="btn-primary" onclick="submitResidentForm()">Submit Availability</button>

            <div id="resident-output" class="hidden" style="margin-top: 24px;">
                <div class="alert alert-success">
                    <strong id="resident-output-title">Availability confirmed!</strong>
                    <p id="resident-output-message" style="margin: 8px 0 0 0;">The organizer will let you know what is the decided date when the schedule is generated.</p>
                    <div id="resident-edit-link-wrap" class="hidden" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.5);">
                        <p style="margin: 0 0 8px 0; font-size: 14px;">Save this link to update your availability later:</p>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <div id="resident-edit-link" style="flex: 1; padding: 8px; background: rgba(255,255,255,0.9); border-radius: 6px; font-family: monospace; font-size: 13px; word-break: break-all;"></div>
                            <button type="button" class="btn-secondary" style="margin: 0; white-space: nowrap;" onclick="navigator.clipboard.writeText(document.getElementById('resident-edit-link').textContent); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy', 2000)">Copy</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SCHEDULE TAB -->
        <div id="schedule-tab" class="tab-content">
            <h1>Generated Schedule</h1>
            <p class="subtitle">Optimal day and massage schedule based on responses</p>

            <div id="schedule-container">
                <div class="alert alert-info">
                    No schedule generated yet. Collect resident responses first, then click "Generate Schedule" below.
                </div>
            </div>

            <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                <button class="btn-primary" onclick="generateSchedule()">Generate Schedule</button>
                <button class="btn-secondary" onclick="viewResponses()">View All Responses</button>
                <button class="btn-danger" id="schedule-delete-btn" onclick="deleteEvent()" style="margin-left: auto; display: none;">Delete this event</button>
            </div>

            <div id="responses-view" class="hidden response-list">
                <h2>All Responses</h2>
                <div id="responses-container"></div>
            </div>
        </div>
    </div>

    <!-- Admin Edit Response Modal -->
    <div id="admin-edit-modal" class="modal-overlay hidden" onclick="if(event.target===this)closeAdminEditModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h2>Edit Availability</h2>
            <div class="form-group">
                <label>Name</label>
                <input type="text" id="admin-edit-name">
            </div>
            <div class="form-group">
                <label>Preferred Length</label>
                <div class="massage-preferences">
                    <div class="preference-option">
                        <input type="radio" name="admin-edit-preferred" value="20" id="admin-pref-20">
                        <label for="admin-pref-20">20 min clothed stretches ($30)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="admin-edit-preferred" value="50" id="admin-pref-50">
                        <label for="admin-pref-50">50 min massage ($70)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="admin-edit-preferred" value="80" id="admin-pref-80">
                        <label for="admin-pref-80">80 min massage ($110)</label>
                    </div>
                    <div class="preference-option">
                        <input type="radio" name="admin-edit-preferred" value="110" id="admin-pref-110">
                        <label for="admin-pref-110">110 min massage ($150)</label>
                    </div>
                </div>
            </div>
            <div class="form-group">
                <label>Backup Preferences (optional)</label>
                <div class="massage-preferences">
                    <div class="preference-option" data-length="20">
                        <input type="checkbox" name="admin-edit-backup" value="20" id="admin-backup-20">
                        <label for="admin-backup-20" style="margin: 0;">20 min</label>
                    </div>
                    <div class="preference-option" data-length="50">
                        <input type="checkbox" name="admin-edit-backup" value="50" id="admin-backup-50">
                        <label for="admin-backup-50" style="margin: 0;">50 min</label>
                    </div>
                    <div class="preference-option" data-length="80">
                        <input type="checkbox" name="admin-edit-backup" value="80" id="admin-backup-80">
                        <label for="admin-backup-80" style="margin: 0;">80 min</label>
                    </div>
                    <div class="preference-option" data-length="110">
                        <input type="checkbox" name="admin-edit-backup" value="110" id="admin-backup-110">
                        <label for="admin-backup-110" style="margin: 0;">110 min</label>
                    </div>
                </div>
            </div>
            <div class="form-group">
                <label>Availability</label>
                <div id="admin-edit-availability-list" class="availability-edit-list"></div>
                <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                    <select id="admin-add-date">
                        <option value="">Add a date...</option>
                    </select>
                    <button type="button" class="btn-secondary" style="margin: 0;" onclick="adminAddAvailabilityDate()">Add</button>
                </div>
            </div>
            <div style="display: flex; gap: 12px; margin-top: 24px;">
                <button class="btn-primary" onclick="saveAdminEdit()">Save Changes</button>
                <button class="btn-secondary" onclick="closeAdminEditModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ========== SUPABASE CONFIG - Replace with your project credentials ==========
        // Get these from: Supabase Dashboard > Project Settings > API
        const SUPABASE_URL = 'https://celhlvfhvkvuyrnizdvq.supabase.co';      // e.g. https://xxxxx.supabase.co
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNlbGhsdmZodmt2dXlybml6ZHZxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1ODQ5NzIsImV4cCI6MjA4NjE2MDk3Mn0.lDK_J_auh6n0K7rEPIveCWWlpWU4EG204IIxWzqIXPc';

        let supabaseClient = null;
        function initSupabase() {
            if (supabaseClient) return true;
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY || 
                SUPABASE_URL === 'YOUR_SUPABASE_URL' || 
                SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') return false;
            try {
                var lib = (typeof window !== 'undefined' && window.supabase) || (typeof supabase !== 'undefined' ? supabase : {});
                if (lib && lib.createClient) {
                    supabaseClient = lib.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                    return true;
                }
            } catch (e) { console.warn('Supabase init failed:', e); }
            return false;
        }
        initSupabase();
        window.addEventListener('load', initSupabase);

        // App state
        let adminData = null;
        let residentResponses = [];
        let currentSessionId = null;  // UUID of the active session (from URL or just created)
        let editingResponseId = null;  // When set, we're editing an existing response
        let editingResponseData = null; // Cached response data for pre-fill

        // Get session ID from URL
        function getSessionIdFromUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('session') || null;
        }

        // Load session from Supabase by ID
        async function loadSession(sessionId) {
            if (!supabaseClient) return null;
            const { data, error } = await supabaseClient
                .from('admin_sessions')
                .select('*')
                .eq('id', sessionId)
                .single();
            if (error) return null;
            return data;
        }

        // Load responses for a session from Supabase
        async function loadResponses(sessionId) {
            if (!supabaseClient) return [];
            const { data, error } = await supabaseClient
                .from('resident_responses')
                .select('*')
                .eq('session_id', sessionId)
                .order('created_at', { ascending: true });
            if (error) return [];
            return data || [];
        }

        // Load a single response by ID (for editing)
        async function loadResponseById(responseId) {
            if (!supabaseClient) return null;
            const { data, error } = await supabaseClient
                .from('resident_responses')
                .select('*')
                .eq('id', responseId)
                .single();
            if (error) return null;
            return data;
        }

        // Convert DB row to adminData format
        function sessionToAdminData(row) {
            return {
                sessionName: row.session_name,
                minHours: row.min_hours,
                dates: row.dates || []
            };
        }

        // Convert DB row to response format
        function rowToResponse(row) {
            return {
                name: row.name,
                preferred: row.preferred,
                backup: row.backup,
                availability: row.availability || [],
                timestamp: row.created_at
            };
        }

        // Tab switching
        function switchTab(tabName, evt) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            const tabIndex = tabName === 'admin' ? 0 : tabName === 'resident' ? 1 : 2;
            document.querySelectorAll('.tab')[tabIndex].classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');

            if (tabName === 'resident' && adminData) {
                loadResidentForm();
            }
        }

        // Calendar state
        let selectedDates = new Set();
        let currentMonth = new Date();
        currentMonth.setDate(1);

        // Initialize calendar on load
        function initCalendar() {
            renderCalendar();
        }

        function renderCalendar() {
            const container = document.getElementById('calendar-container');
            if (!container) return;
            const year = currentMonth.getFullYear();
            const month = currentMonth.getMonth();
            
            const monthName = currentMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let html = `
                <div class="calendar">
                    <div class="calendar-header">
                        <button onclick="changeMonth(-1)">←</button>
                        <div class="calendar-title">${monthName}</div>
                        <button onclick="changeMonth(1)">→</button>
                    </div>
                    <div class="calendar-grid">
                        <div class="calendar-day-header">Sun</div>
                        <div class="calendar-day-header">Mon</div>
                        <div class="calendar-day-header">Tue</div>
                        <div class="calendar-day-header">Wed</div>
                        <div class="calendar-day-header">Thu</div>
                        <div class="calendar-day-header">Fri</div>
                        <div class="calendar-day-header">Sat</div>
            `;
            
            // Empty cells before first day
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day empty"></div>';
            }
            
            // Days of month
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                date.setHours(0, 0, 0, 0);
                const dateStr = date.toISOString().split('T')[0];
                const isSelected = selectedDates.has(dateStr);
                const isToday = date.getTime() === today.getTime();
                
                const classes = ['calendar-day'];
                if (isSelected) classes.push('selected');
                if (isToday) classes.push('today');
                
                html += `<div class="${classes.join(' ')}" onclick="toggleDate('${dateStr}')">${day}</div>`;
            }
            
            html += '</div></div>';
            container.innerHTML = html;
            
            updateSelectedDatesDisplay();
        }

        function changeMonth(delta) {
            currentMonth.setMonth(currentMonth.getMonth() + delta);
            renderCalendar();
        }

        function toggleDate(dateStr) {
            if (selectedDates.has(dateStr)) {
                selectedDates.delete(dateStr);
            } else {
                selectedDates.add(dateStr);
            }
            renderCalendar();
        }

        function updateSelectedDatesDisplay() {
            const display = document.getElementById('selected-dates-display');
            const list = document.getElementById('selected-dates-list');
            
            if (selectedDates.size === 0) {
                display.style.display = 'none';
                return;
            }
            
            display.style.display = 'block';
            
            const sortedDates = Array.from(selectedDates).sort();
            list.innerHTML = sortedDates.map(dateStr => {
                const date = new Date(dateStr + 'T12:00:00');
                const formatted = date.toLocaleDateString('en-US', { 
                    weekday: 'short', 
                    month: 'short', 
                    day: 'numeric' 
                });
                return `<span class="selected-date-tag">${formatted}</span>`;
            }).join('');
        }

        async function saveAdminSetup() {
            initSupabase();
            if (!supabaseClient) {
                alert('Supabase not configured. Add your SUPABASE_URL and SUPABASE_ANON_KEY to index.html');
                return;
            }

            const sessionName = document.getElementById('session-name').value;
            const minHours = 7; // Always 7 hours minimum
            const dates = [];

            if (selectedDates.size === 0) {
                alert('Please select at least one date from the calendar');
                return;
            }

            selectedDates.forEach(dateStr => {
                dates.push({ date: dateStr });
            });

            const sortedDates = dates.sort((a, b) => new Date(a.date) - new Date(b.date));

            const { data: session, error } = await supabaseClient
                .from('admin_sessions')
                .insert({
                    session_name: sessionName || 'Massage Session',
                    min_hours: minHours,
                    dates: sortedDates
                })
                .select()
                .single();

            if (error) {
                alert('Error saving: ' + error.message);
                return;
            }

            currentSessionId = session.id;
            adminData = sessionToAdminData(session);

            // Update URL so admin has the session link (admin view - no view param)
            const baseUrl = window.location.href.split('?')[0];
            const adminUrl = baseUrl + '?session=' + currentSessionId;
            const residentUrl = baseUrl + '?view=resident&session=' + currentSessionId;
            window.history.replaceState({}, '', adminUrl);

            // Save to recent sessions (localStorage)
            saveToRecentSessions(session.id, session.session_name);

            // Show success message
            const output = document.getElementById('admin-output');
            document.getElementById('form-link').textContent = residentUrl;
            output.classList.remove('hidden');
            updateDeleteButtonVisibility();
        }

        function saveToRecentSessions(id, name) {
            try {
                var list = JSON.parse(localStorage.getItem('massageScheduler_recent') || '[]');
                list = list.filter(s => s.id !== id);
                list.unshift({ id, name: name || 'Massage Session', createdAt: new Date().toISOString() });
                list = list.slice(0, 10);
                localStorage.setItem('massageScheduler_recent', JSON.stringify(list));
            } catch (e) {}
        }

        function loadRecentSessions() {
            try {
                var list = JSON.parse(localStorage.getItem('massageScheduler_recent') || '[]');
                return list;
            } catch (e) { return []; }
        }

        function openSession(sessionId) {
            window.location.href = window.location.href.split('?')[0] + '?session=' + sessionId;
        }

        function renderRecentSessions() {
            var container = document.getElementById('recent-sessions');
            var listEl = document.getElementById('recent-sessions-list');
            if (!container || !listEl) return;
            var sessions = loadRecentSessions();
            if (sessions.length === 0) {
                container.classList.add('hidden');
                return;
            }
            container.classList.remove('hidden');
            listEl.innerHTML = sessions.map(function(s) {
                var date = new Date(s.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                return '<a href="#" onclick="openSession(\'' + s.id + '\'); return false;" style="display: block; padding: 10px 14px; margin-bottom: 6px; background: rgba(255,255,255,0.9); border-radius: 10px; border: 1px solid rgba(45,45,38,0.1); text-decoration: none; color: #2d2d26;">' + (s.name || 'Session') + ' <span style="color: #6b6b5e; font-size: 13px;">(' + date + ')</span></a>';
            }).join('');
        }

        async function deleteEvent() {
            if (!supabaseClient || !currentSessionId) return;
            if (!confirm('Delete this event? All resident responses will be permanently removed.')) return;

            const { error } = await supabaseClient
                .from('admin_sessions')
                .delete()
                .eq('id', currentSessionId);

            if (error) {
                alert('Error deleting: ' + error.message);
                return;
            }

            var deletedId = currentSessionId;
            currentSessionId = null;
            adminData = null;
            residentResponses = [];

            // Remove from recent sessions
            try {
                var list = JSON.parse(localStorage.getItem('massageScheduler_recent') || '[]');
                list = list.filter(function(s) { return s.id !== deletedId; });
                localStorage.setItem('massageScheduler_recent', JSON.stringify(list));
            } catch (e) {}

            // Clear URL and refresh to show fresh admin setup
            window.location.href = window.location.href.split('?')[0];
        }

        function updateDeleteButtonVisibility() {
            const btn = document.getElementById('schedule-delete-btn');
            if (btn) btn.style.display = currentSessionId ? 'inline-block' : 'none';
        }

        // Resident Form Functions
        let residentCalendarMonth = new Date();
        residentCalendarMonth.setDate(1);
        let residentAvailability = {}; // { 'YYYY-MM-DD': { from: 'HH:MM', until: 'HH:MM' } }
        let currentSelectedDate = null;
        let isDragging = false;
        let dragStartSlot = null;

        // Update backup options when preferred changes
        function updateBackupOptions() {
            const preferred = document.querySelector('input[name="preferred-length"]:checked');
            if (!preferred) return;
            
            const preferredValue = preferred.value;
            
            // Show/hide backup options based on preferred
            document.querySelectorAll('.preference-option[data-length]').forEach(option => {
                const length = option.getAttribute('data-length');
                const checkbox = option.querySelector('input[type="checkbox"]');
                
                if (length === preferredValue) {
                    option.style.display = 'none';
                    checkbox.checked = false; // Uncheck if it was checked
                } else {
                    option.style.display = 'flex';
                }
            });
        }

        // Add event listeners to preferred length radios
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('input[name="preferred-length"]').forEach(radio => {
                radio.addEventListener('change', updateBackupOptions);
            });
            // Run once on load
            updateBackupOptions();
        });

        function loadResidentForm() {
            if (!adminData) {
                document.getElementById('resident-calendar-container').innerHTML = 
                    '<div class="alert alert-warning">Admin setup not complete yet.</div>';
                return;
            }

            renderResidentCalendar();
            if (editingResponseData) prefillResidentForm(editingResponseData);
            updateResidentSubmitButton();
        }

        function prefillResidentForm(row) {
            if (!row) return;
            document.getElementById('resident-name').value = row.name || '';
            const preferredRadio = document.querySelector(`input[name="preferred-length"][value="${row.preferred}"]`);
            if (preferredRadio) preferredRadio.checked = true;
            document.querySelectorAll('input[name="backup-length"]').forEach(cb => {
                cb.checked = row.backup && Array.isArray(row.backup) && row.backup.includes(parseInt(cb.value));
            });
            residentAvailability = {};
            (row.availability || []).forEach(avail => {
                residentAvailability[avail.date] = { from: avail.from, until: avail.until };
            });
            renderResidentCalendar();
            updateAvailabilitySummary();
            if (Object.keys(residentAvailability).length > 0) {
                document.getElementById('resident-availability-summary').classList.remove('hidden');
            }
            updateBackupOptions();
        }

        function updateResidentSubmitButton() {
            const btn = document.getElementById('resident-submit-btn');
            if (btn) btn.textContent = editingResponseId ? 'Update Availability' : 'Submit Availability';
        }

        function renderResidentCalendar() {
            const container = document.getElementById('resident-calendar-container');
            const year = residentCalendarMonth.getFullYear();
            const month = residentCalendarMonth.getMonth();
            
            const monthName = residentCalendarMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Get available dates from admin
            const availableDates = new Set(adminData.dates.map(d => d.date));
            
            let html = `
                <div class="calendar">
                    <div class="calendar-header">
                        <button onclick="changeResidentMonth(-1)">←</button>
                        <div class="calendar-title">${monthName}</div>
                        <button onclick="changeResidentMonth(1)">→</button>
                    </div>
                    <div class="calendar-grid">
                        <div class="calendar-day-header">Sun</div>
                        <div class="calendar-day-header">Mon</div>
                        <div class="calendar-day-header">Tue</div>
                        <div class="calendar-day-header">Wed</div>
                        <div class="calendar-day-header">Thu</div>
                        <div class="calendar-day-header">Fri</div>
                        <div class="calendar-day-header">Sat</div>
            `;
            
            for (let i = 0; i < firstDay; i++) {
                html += '<div class="calendar-day empty"></div>';
            }
            
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                date.setHours(0, 0, 0, 0);
                const dateStr = date.toISOString().split('T')[0];
                const isAvailable = availableDates.has(dateStr);
                const hasAvailability = residentAvailability[dateStr];
                const isToday = date.getTime() === today.getTime();
                
                const classes = ['calendar-day'];
                if (!isAvailable) classes.push('other-month');
                if (hasAvailability) classes.push('selected');
                if (isToday && isAvailable) classes.push('today');
                
                const onclick = isAvailable ? `onclick="selectResidentDate('${dateStr}')"` : '';
                
                html += `<div class="${classes.join(' ')}" ${onclick}>${day}</div>`;
            }
            
            html += '</div></div>';
            container.innerHTML = html;
        }

        function changeResidentMonth(delta) {
            residentCalendarMonth.setMonth(residentCalendarMonth.getMonth() + delta);
            renderResidentCalendar();
        }

        function selectResidentDate(dateStr) {
            currentSelectedDate = dateStr;
            const date = new Date(dateStr + 'T12:00:00');
            const formatted = date.toLocaleDateString('en-US', { 
                weekday: 'long', 
                month: 'long', 
                day: 'numeric' 
            });
            
            document.getElementById('selected-date-title').textContent = formatted;
            document.getElementById('time-selector').classList.remove('hidden');
            
            renderTimeGrid(dateStr);
        }

        function renderTimeGrid(dateStr) {
            const grid = document.getElementById('time-grid');
            
            // Generate 30-min slots from 8am to 8pm
            const slots = [];
            for (let hour = 8; hour <= 20; hour++) {
                for (let min = 0; min < 60; min += 30) {
                    const time = `${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                    slots.push(time);
                }
            }
            
            const existing = residentAvailability[dateStr];
            let selectedSlots = new Set();
            
            if (existing) {
                const fromIdx = slots.indexOf(existing.from);
                const untilIdx = slots.indexOf(existing.until);
                for (let i = fromIdx; i <= untilIdx; i++) {
                    selectedSlots.add(slots[i]);
                }
            }
            
            let html = '<div class="time-grid">';
            slots.forEach((slot, idx) => {
                const isSelected = selectedSlots.has(slot);
                const displayTime = formatTimeSlot(slot);
                html += `<div class="time-slot ${isSelected ? 'selected' : ''}" 
                    data-slot="${slot}" 
                    data-idx="${idx}"
                    onmousedown="startDrag(${idx})"
                    onmouseenter="continueDrag(${idx})"
                    onmouseup="endDrag()">${displayTime}</div>`;
            });
            html += '</div>';
            
            grid.innerHTML = html;
        }

        function formatTimeSlot(time) {
            const [hour, min] = time.split(':').map(Number);
            const period = hour >= 12 ? 'pm' : 'am';
            const displayHour = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
            return min === 0 ? `${displayHour}${period}` : `${displayHour}:${min}${period}`;
        }

        function startDrag(idx) {
            isDragging = true;
            dragStartSlot = idx;
            
            // Check if we're starting on a selected slot - if so, we're deselecting
            const startSlot = document.querySelector(`[data-idx="${idx}"]`);
            const isDeselecting = startSlot.classList.contains('selected');
            
            // Store this for the drag operation
            window.dragMode = isDeselecting ? 'deselect' : 'select';
            
            toggleSlot(idx);
        }

        function continueDrag(idx) {
            if (!isDragging) return;
            
            const slots = document.querySelectorAll('.time-slot');
            const start = Math.min(dragStartSlot, idx);
            const end = Math.max(dragStartSlot, idx);
            
            // Apply selection/deselection to the drag range
            slots.forEach((slot, i) => {
                if (i >= start && i <= end) {
                    if (window.dragMode === 'select') {
                        slot.classList.add('selected');
                    } else {
                        slot.classList.remove('selected');
                    }
                }
            });
        }

        function endDrag() {
            if (isDragging && currentSelectedDate && !document.getElementById('time-selector').classList.contains('hidden')) {
                saveTimeSelection(true);
            }
            isDragging = false;
            dragStartSlot = null;
            window.dragMode = null;
        }

        function toggleSlot(idx) {
            const slot = document.querySelector(`[data-idx="${idx}"]`);
            if (window.dragMode === 'select') {
                slot.classList.add('selected');
            } else {
                slot.classList.remove('selected');
            }
        }

        function clearTimeSelection() {
            document.querySelectorAll('.time-slot').forEach(slot => {
                slot.classList.remove('selected', 'in-range');
            });
            saveTimeSelection(true);
        }

        function saveTimeSelection(keepOpen) {
            if (!currentSelectedDate) return;
            const selectedSlots = Array.from(document.querySelectorAll('.time-slot.selected'))
                .map(slot => slot.getAttribute('data-slot'))
                .sort();
            
            if (selectedSlots.length === 0) {
                delete residentAvailability[currentSelectedDate];
            } else {
                // Find earliest and latest selected times
                residentAvailability[currentSelectedDate] = {
                    from: selectedSlots[0],
                    until: selectedSlots[selectedSlots.length - 1]
                };
            }
            
            renderResidentCalendar();
            updateAvailabilitySummary();
            if (!keepOpen) {
                document.getElementById('time-selector').classList.add('hidden');
            }
        }

        function updateAvailabilitySummary() {
            const summary = document.getElementById('resident-availability-summary');
            const list = document.getElementById('availability-summary-list');
            
            const dates = Object.keys(residentAvailability).sort();
            
            if (dates.length === 0) {
                summary.classList.add('hidden');
                return;
            }
            
            summary.classList.remove('hidden');
            
            list.innerHTML = dates.map(dateStr => {
                const date = new Date(dateStr + 'T12:00:00');
                const formatted = date.toLocaleDateString('en-US', { 
                    weekday: 'short', 
                    month: 'short', 
                    day: 'numeric' 
                });
                const avail = residentAvailability[dateStr];
                return `<div class="availability-summary-item">${formatted}: ${formatTimeSlot(avail.from)} - ${formatTimeSlot(avail.until)}</div>`;
            }).join('');
        }

        // Stop dragging when mouse leaves the grid
        document.addEventListener('mouseup', endDrag);

        async function submitResidentForm() {
            initSupabase();
            if (!supabaseClient) {
                alert('Supabase not configured. Add your SUPABASE_URL and SUPABASE_ANON_KEY to index.html');
                return;
            }

            if (!currentSessionId) {
                alert('Session not found. Please use the link shared by the admin.');
                return;
            }

            const name = document.getElementById('resident-name').value.trim();
            if (!name) {
                alert('Please enter your name');
                return;
            }

            const preferred = document.querySelector('input[name="preferred-length"]:checked').value;
            const backupCheckboxes = document.querySelectorAll('input[name="backup-length"]:checked');
            const backup = Array.from(backupCheckboxes).map(cb => parseInt(cb.value));
            
            if (Object.keys(residentAvailability).length === 0) {
                alert('Please select at least one date and set your available times');
                return;
            }

            const availability = Object.keys(residentAvailability).map(date => ({
                date,
                from: residentAvailability[date].from,
                until: residentAvailability[date].until
            }));

            const payload = {
                name,
                preferred: parseInt(preferred),
                backup: backup.length > 0 ? backup : null,
                availability
            };

            let savedId = editingResponseId;

            if (editingResponseId) {
                const { error } = await supabaseClient
                    .from('resident_responses')
                    .update(payload)
                    .eq('id', editingResponseId);

                if (error) {
                    alert('Error updating: ' + error.message);
                    return;
                }
            } else {
                const { data, error } = await supabaseClient
                    .from('resident_responses')
                    .insert({ session_id: currentSessionId, ...payload })
                    .select('id')
                    .single();

                if (error) {
                    alert('Error submitting: ' + error.message);
                    return;
                }
                savedId = data.id;
            }

            // Show success
            document.getElementById('resident-output').classList.remove('hidden');
            document.getElementById('resident-output-title').textContent = editingResponseId ? 'Availability updated!' : 'Availability confirmed!';
            document.getElementById('resident-output-message').textContent = 'The organizer will let you know what is the decided date when the schedule is generated.';

            const editLinkWrap = document.getElementById('resident-edit-link-wrap');
            if (editingResponseId) {
                editLinkWrap.classList.add('hidden');
            } else {
                const baseUrl = window.location.href.split('?')[0];
                const editUrl = baseUrl + '?view=resident&session=' + currentSessionId + '&edit=' + savedId;
                document.getElementById('resident-edit-link').textContent = editUrl;
                editLinkWrap.classList.remove('hidden');
            }

            document.getElementById('resident-output').scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            // Reset form for new submissions (keep success message visible so they can copy the link)
            if (!editingResponseId) {
                document.getElementById('resident-name').value = '';
                document.querySelectorAll('input[name="backup-length"]').forEach(cb => cb.checked = false);
                residentAvailability = {};
                renderResidentCalendar();
                updateAvailabilitySummary();
                document.getElementById('time-selector').classList.add('hidden');
                document.querySelector('input[name="preferred-length"][value="80"]').checked = true;
                updateBackupOptions();
            }
        }

        // Schedule Generation Functions
        async function generateSchedule() {
            if (!currentSessionId || !adminData) {
                alert('No session loaded. Create one in Admin Setup first.');
                return;
            }

            // Fetch fresh responses from Supabase
            const responses = await loadResponses(currentSessionId);
            residentResponses = responses.map(rowToResponse);

            if (residentResponses.length === 0) {
                alert('No resident responses yet. Share the form link and collect responses first.');
                return;
            }

            // Find best date
            const dateScores = {};
            
            adminData.dates.forEach(dateOption => {
                dateScores[dateOption.date] = {
                    count: 0,
                    people: []
                };
            });

            // Count availability per date
            residentResponses.forEach(response => {
                response.availability.forEach(avail => {
                    if (dateScores[avail.date]) {
                        dateScores[avail.date].count++;
                        dateScores[avail.date].people.push({
                            name: response.name,
                            from: avail.from,
                            until: avail.until,
                            preferred: response.preferred,
                            backup: response.backup
                        });
                    }
                });
            });

            // Find date with most people
            let bestDate = null;
            let maxCount = 0;

            Object.keys(dateScores).forEach(date => {
                if (dateScores[date].count > maxCount) {
                    maxCount = dateScores[date].count;
                    bestDate = date;
                }
            });

            if (!bestDate) {
                alert('No overlapping availability found');
                return;
            }

            // Find optimal start time for that date
            const bestDateData = dateScores[bestDate];
            
            // Generate possible start times (every 15 min from 8:30am to 5pm)
            const possibleStartTimes = [];
            // Start at 8:30am
            possibleStartTimes.push('08:30');
            possibleStartTimes.push('08:45');
            // Then 9am onwards
            for (let hour = 9; hour <= 17; hour++) {
                for (let min = 0; min < 60; min += 15) {
                    possibleStartTimes.push(`${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`);
                }
            }

            let bestSchedule = null;
            let maxFit = 0;

            possibleStartTimes.forEach(startTime => {
                const schedule = buildSchedule(bestDateData.people, startTime);
                if (schedule.appointments.length > maxFit) {
                    maxFit = schedule.appointments.length;
                    bestSchedule = schedule;
                    bestSchedule.startTime = startTime;
                }
            });

            // Display schedule
            displaySchedule(bestDate, bestSchedule, bestDateData.people.length);
        }

        function buildSchedule(people, startTime) {
            const schedule = { appointments: [], breaks: [], totalHours: 0, totalCost: 0 };
            const [startHour, startMin] = startTime.split(':').map(Number);
            let currentTime = startHour * 60 + startMin; // minutes since midnight
            let lastBreak = currentTime;

            // Sort people by preferred duration (longest first for efficiency)
            const sortedPeople = [...people].sort((a, b) => b.preferred - a.preferred);

            sortedPeople.forEach(person => {
                const [fromHour, fromMin] = person.from.split(':').map(Number);
                const [untilHour, untilMin] = person.until.split(':').map(Number);
                const availFrom = fromHour * 60 + fromMin;
                const availUntil = untilHour * 60 + untilMin;

                // Try preferred duration first
                let duration = person.preferred;
                let slotEnd = currentTime + duration + 10; // +10 for turnover

                let foundSlot = false;

                // If preferred doesn't fit, try backup options
                if (slotEnd > availUntil && person.backup && Array.isArray(person.backup)) {
                    for (const backupDuration of person.backup) {
                        duration = backupDuration;
                        slotEnd = currentTime + duration + 10;
                        if (slotEnd <= availUntil) {
                            foundSlot = true;
                            break;
                        }
                    }
                } else if (slotEnd <= availUntil) {
                    foundSlot = true;
                }

                // Check if person is available and duration fits
                if (currentTime >= availFrom && foundSlot) {
                    // Check if we need a break (every 3-4 hours)
                    if (currentTime - lastBreak >= 180) { // 3 hours
                        schedule.breaks.push({
                            time: currentTime,
                            duration: 20
                        });
                        currentTime += 20;
                        lastBreak = currentTime;
                    }

                    schedule.appointments.push({
                        name: person.name,
                        time: currentTime,
                        duration: duration,
                        cost: getCost(duration)
                    });

                    schedule.totalCost += getCost(duration);
                    currentTime += duration + 10; // appointment + turnover
                }
            });

            schedule.totalHours = (currentTime - (startHour * 60 + startMin)) / 60;
            return schedule;
        }

        function getCost(duration) {
            const costs = { 20: 30, 50: 70, 80: 110, 110: 150 };
            return costs[duration] || 0;
        }

        function displaySchedule(date, schedule, totalAvailable) {
            const container = document.getElementById('schedule-container');
            const dateStr = new Date(date).toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            });

            const meetsMinimum = schedule.totalHours >= adminData.minHours;

            let html = `
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value">${dateStr}</div>
                        <div class="stat-label">Selected Date</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${schedule.appointments.length} / ${totalAvailable}</div>
                        <div class="stat-label">People Scheduled</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${schedule.totalHours.toFixed(1)}h</div>
                        <div class="stat-label">Total Hours</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">$${schedule.totalCost}</div>
                        <div class="stat-label">Total Revenue</div>
                    </div>
                </div>

                ${!meetsMinimum ? `
                    <div class="alert alert-warning">
                        ⚠️ Only ${schedule.totalHours.toFixed(1)} hours scheduled. Need ${adminData.minHours}+ hours minimum.
                    </div>
                ` : `
                    <div class="alert alert-success">
                        ✓ ${schedule.totalHours.toFixed(1)} hours scheduled - meets ${adminData.minHours}h minimum!
                    </div>
                `}

                <div class="schedule-header">
                    <h2 style="margin: 0; color: #f5f2ea;">Massage Schedule</h2>
                    <div style="margin-top: 4px; opacity: 0.9;">Start: ${schedule.startTime} | End: ${formatTime(schedule.appointments[schedule.appointments.length - 1].time + schedule.appointments[schedule.appointments.length - 1].duration)}</div>
                </div>

                <div class="schedule-output">
            `;

            // Combine appointments and breaks, then sort by time
            const allSlots = [
                ...schedule.appointments.map(apt => ({ ...apt, type: 'appointment' })),
                ...schedule.breaks.map(brk => ({ ...brk, type: 'break' }))
            ].sort((a, b) => a.time - b.time);

            allSlots.forEach(slot => {
                if (slot.type === 'break') {
                    html += `
                        <div class="schedule-slot break">
                            <div class="slot-time">${formatTime(slot.time)} - BREAK (20 min)</div>
                            <div class="slot-details">Masseuse break</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="schedule-slot">
                            <div class="slot-time">${formatTime(slot.time)} - ${slot.name}</div>
                            <div class="slot-details">${slot.duration} min massage · $${slot.cost}</div>
                        </div>
                    `;
                }
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function formatTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const period = hours >= 12 ? 'pm' : 'am';
            const displayHours = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);
            return `${displayHours}:${mins.toString().padStart(2, '0')}${period}`;
        }

        async function viewResponses() {
            const container = document.getElementById('responses-container');
            const view = document.getElementById('responses-view');

            if (!currentSessionId) {
                alert('No session loaded.');
                return;
            }

            // Fetch fresh responses from Supabase
            const responses = await loadResponses(currentSessionId);
            lastViewedResponseRows = responses;
            residentResponses = responses.map(rowToResponse);

            if (responses.length === 0) {
                alert('No responses yet');
                return;
            }

            let html = '';
            responses.forEach((row, idx) => {
                const response = rowToResponse(row);
                const backupText = response.backup && response.backup.length > 0 
                    ? ` | Backup: ${response.backup.join(', ')} min` 
                    : '';
                
                html += `
                    <div class="response-item">
                        <div class="response-item-details">
                            <strong>${response.name}</strong><br>
                            Preferred: ${response.preferred} min ($${getCost(response.preferred)})${backupText}<br>
                            <small style="color: #6b7280;">
                                Available: ${response.availability.map(a => {
                                    const date = new Date(a.date + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                    return `${date} (${a.from}-${a.until})`;
                                }).join(', ')}
                            </small>
                        </div>
                        <button type="button" class="btn-secondary" style="margin: 0; white-space: nowrap;" onclick="openAdminEditModal(${idx})">Edit</button>
                    </div>
                `;
            });

            container.innerHTML = html;
            view.classList.remove('hidden');
        }

        let adminEditingRow = null;
        let lastViewedResponseRows = [];

        function getTimeSlots() {
            const slots = [];
            for (let hour = 8; hour <= 20; hour++) {
                for (let min = 0; min < 60; min += 30) {
                    slots.push(`${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`);
                }
            }
            return slots;
        }

        function openAdminEditModal(idx) {
            adminEditingRow = lastViewedResponseRows[idx];
            if (!adminEditingRow) return;
            document.getElementById('admin-edit-name').value = row.name || '';
            document.querySelector(`input[name="admin-edit-preferred"][value="${row.preferred}"]`).checked = true;
            document.querySelectorAll('input[name="admin-edit-backup"]').forEach(cb => {
                cb.checked = row.backup && Array.isArray(row.backup) && row.backup.includes(parseInt(cb.value));
            });
            adminEditUpdateBackupOptions();
            renderAdminAvailabilityList(row.availability || []);
            adminPopulateAddDateDropdown();
            document.getElementById('admin-edit-modal').classList.remove('hidden');
        }

        function closeAdminEditModal() {
            adminEditingRow = null;
            document.getElementById('admin-edit-modal').classList.add('hidden');
        }

        function adminEditUpdateBackupOptions() {
            const preferred = document.querySelector('input[name="admin-edit-preferred"]:checked');
            if (!preferred) return;
            const val = preferred.value;
            document.querySelectorAll('.modal-content .preference-option[data-length]').forEach(opt => {
                opt.style.display = opt.getAttribute('data-length') === val ? 'none' : 'flex';
                const cb = opt.querySelector('input[type="checkbox"]');
                if (opt.getAttribute('data-length') === val) cb.checked = false;
            });
        }

        function renderAdminAvailabilityList(availability) {
            const container = document.getElementById('admin-edit-availability-list');
            const slots = getTimeSlots();
            
            let html = '';
            availability.forEach((a, i) => {
                const fromOpts = slots.map(s => `<option value="${s}" ${s === a.from ? 'selected' : ''}>${formatTimeSlot(s)}</option>`).join('');
                const toOpts = slots.map(s => `<option value="${s}" ${s === a.until ? 'selected' : ''}>${formatTimeSlot(s)}</option>`).join('');
                const dateLabel = new Date(a.date + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                html += `<div class="availability-edit-row" data-date="${a.date}">
                    <span>${dateLabel}</span>
                    <select data-field="from">${fromOpts}</select>
                    <select data-field="until">${toOpts}</select>
                    <button type="button" class="remove-btn" onclick="adminRemoveAvailabilityDate('${a.date}')" title="Remove">×</button>
                </div>`;
            });
            container.innerHTML = html || '<p style="color: #6b7280; font-size: 14px;">No dates added. Use the dropdown below to add.</p>';
        }

        function adminAddAvailabilityDate() {
            const sel = document.getElementById('admin-add-date');
            const dateStr = sel.value;
            if (!dateStr) return;
            const avail = adminEditingRow.availability || [];
            if (avail.some(a => a.date === dateStr)) return;
            avail.push({ date: dateStr, from: '08:00', until: '20:00' });
            adminEditingRow.availability = avail;
            renderAdminAvailabilityList(avail);
            adminPopulateAddDateDropdown();
            sel.value = '';
        }

        function adminRemoveAvailabilityDate(dateStr) {
            adminEditingRow.availability = (adminEditingRow.availability || []).filter(a => a.date !== dateStr);
            renderAdminAvailabilityList(adminEditingRow.availability);
            adminPopulateAddDateDropdown();
        }

        function adminPopulateAddDateDropdown() {
            const sel = document.getElementById('admin-add-date');
            const used = new Set((adminEditingRow.availability || []).map(a => a.date));
            const available = (adminData.dates || []).map(d => d.date).filter(d => !used.has(d));
            sel.innerHTML = '<option value="">Add a date...</option>' + 
                available.map(d => {
                    const lab = new Date(d + 'T12:00:00').toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    return `<option value="${d}">${lab}</option>`;
                }).join('');
        }

        function collectAdminEditData() {
            const name = document.getElementById('admin-edit-name').value.trim();
            const preferred = parseInt(document.querySelector('input[name="admin-edit-preferred"]:checked')?.value || 80);
            const backup = Array.from(document.querySelectorAll('input[name="admin-edit-backup"]:checked')).map(cb => parseInt(cb.value));
            const availability = [];
            document.querySelectorAll('.availability-edit-row').forEach(row => {
                const dateStr = row.dataset.date;
                if (dateStr) {
                    const from = row.querySelector('select[data-field="from"]').value;
                    const until = row.querySelector('select[data-field="until"]').value;
                    availability.push({ date: dateStr, from, until });
                }
            });
            return { name, preferred, backup, availability };
        }

        async function saveAdminEdit() {
            if (!adminEditingRow || !supabaseClient) return;
            const { name, preferred, backup, availability } = collectAdminEditData();
            if (!name) {
                alert('Please enter a name');
                return;
            }
            if (availability.length === 0) {
                alert('Please add at least one date with availability');
                return;
            }
            const { error } = await supabaseClient
                .from('resident_responses')
                .update({ name, preferred, backup: backup.length ? backup : null, availability })
                .eq('id', adminEditingRow.id);

            if (error) {
                alert('Error updating: ' + error.message);
                return;
            }
            closeAdminEditModal();
            viewResponses();
        }

        document.querySelectorAll('input[name="admin-edit-preferred"]').forEach(r => {
            r.addEventListener('change', adminEditUpdateBackupOptions);
        });

        // Render calendar immediately when DOM is ready (don't wait for Supabase)
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCalendar);
        } else {
            initCalendar();
        }

        // Check URL params on load (after all resources including Supabase)
        window.addEventListener('load', async () => {
            const params = new URLSearchParams(window.location.search);
            const sessionId = params.get('session');
            const view = params.get('view');
            const editId = params.get('edit');

            if (sessionId && supabaseClient) {
                const session = await loadSession(sessionId);
                if (session) {
                    currentSessionId = sessionId;
                    adminData = sessionToAdminData(session);
                    saveToRecentSessions(session.id, session.session_name);
                    // If resident view with edit link, load existing response
                    if (view === 'resident' && editId) {
                        const response = await loadResponseById(editId);
                        if (response && response.session_id === sessionId) {
                            editingResponseId = editId;
                            editingResponseData = response;
                        }
                    }
                    // If admin view, show the resident link so they can copy it again
                    if (view !== 'resident') {
                        const baseUrl = window.location.href.split('?')[0];
                        const residentUrl = baseUrl + '?view=resident&session=' + sessionId;
                        document.getElementById('form-link').textContent = residentUrl;
                        document.getElementById('admin-output').classList.remove('hidden');
                        updateDeleteButtonVisibility();
                    }
                } else if (view === 'resident') {
                    // Resident link but session not found - redirect to admin
                    window.location.replace(window.location.href.split('?')[0]);
                    return;
                }
            }

            if (view === 'resident' && adminData) {
                document.getElementById('app-container').classList.add('resident-view');
                switchTab('resident');
            } else {
                document.getElementById('app-container').classList.remove('resident-view');
            }

            renderRecentSessions();
        });
    </script>
</body>
</html>
